% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pathimp.R
\name{pathimp}
\alias{pathimp}
\title{Regression-Imputation estimator for path-specific effects}
\usage{
pathimp(
  D,
  Y,
  M,
  Y_models,
  D_model = NULL,
  data,
  boot_reps,
  boot_conf_level = 0.95,
  boot_seed = NULL,
  boot_parallel = "no",
  round_decimal = 3,
  boot_cores = max(c(parallel::detectCores() - 2, 1)),
  out_ipw
)
}
\arguments{
\item{D}{A character string indicating the name of the treatment variable in
\code{data}. The treatment should be a binary variable taking either 0 or 1.}

\item{Y}{A character string indicating the name of the outcome variable.}

\item{M}{a list of \eqn{K} character vectors indicating the names of \eqn{K}
causally ordered mediators \eqn{M_1,\ldots, M_K}.}

\item{Y_models}{a list of \eqn{K+1} fitted model objects describing how the
outcome depends on treatment, pretreatment confounders, and varying sets of
mediators, where \eqn{K} is the number of mediators.
\itemize{
\item the first element is a baseline model of the outcome conditional on
treatment and pretreatment confounders.
\item the \eqn{k}th element is an outcome model conditional on treatment,
pretreatment confounders, and mediators \eqn{M_1,\ldots, M_{k-1}}.
\item the last element is an outcome model conditional on treatment,
pretreatment confounders, and all of the mediators, i.e.,
\eqn{M_1,\ldots, M_K}.
}

The fitted model objects can be of type \code{\link{lm}}, \code{\link{glm}},
\code{\link[gbm]{gbm}}, \code{\link[BART]{wbart}}, or \code{\link[BART]{pbart}}.}

\item{data}{A data frame.}

\item{boot_conf_level}{A numeric scalar for the confidence level of the
bootstrap interval.}

\item{boot_seed}{An integer scalar specifying the random-number seed used in
bootstrap resampling. Defaults to \code{NULL}, indicating that no seed is set.}

\item{boot_parallel}{Type of parallel operation to be used. Follows the same
specification as the \code{\link[boot]{boot}} package. Defaults to \code{"no"}.}

\item{round_decimal}{The number of decimal digits to which results are
rounded and displayed.}

\item{boot_cores}{An integer scalar specifying the number of CPU cores on
which the parallelized bootstrap will run. This argument only has an effect
if you requested a parallelized bootstrap (i.e., only if \code{boot_parallel} is
not \code{no}). By default, \code{boot_cores} is equal to the greater of two values:
(a) one and (b) the number of available CPU cores minus two. If \code{boot_cores}
equals one, then the bootstrap loop will not be parallelized (regardless of
the setting of \code{boot_parallel}).}

\item{out_ipw}{A logical value indicating whether to report the
imputation-based weighting estimator. If set to \code{TRUE}, the user must
specify the propensity score model to calculate the Imputation-based Weighting
Estimator . If \code{FALSE}, only the Pure Imputation Estimator will be
returned.}

\item{D_model:}{an optional propensity score model for treatment. It can be
of type \code{\link{glm}},\code{\link[gbm]{gbm}}, \code{\link[twang]{ps}}, or
\code{\link[BART]{pbart}}. When it is provided, the imputation-based weighting
estimator is also used to compute path-specific causal effects. Defaults to
\code{NULL}. Must be explicitly specified when \code{out_ipw = TRUE} to compute the
imputation-based weighting estimator.}
}
\value{
When \code{out_ipw = TRUE}, \code{pathimp()} returns a dataframe with the
following information: \describe{
\item{Pure Imputation Estimator}{Estimates the direct (ATE) and path-specific
effects (PSE)  through mediators \eqn{M_1, \ldots, M_K} using the pure
imputation estimator, along with corresponding bootstrap confidence intervals.}
\item{Imputation-based Weighting Estimator}{Estimates of direct and
path-specific effects via \eqn{M_1, \ldots, M_K} based on the imputation-based
weighting estimator,along with corresponding bootstrap confidence intervals.}
} When \code{out_ipw = FALSE}, only the pure imputation estimator will be
returned.
}
\description{
\code{pathimp()} is a wrapper for two functions from the \code{paths} package. It
implements the pure imputation estimator and the imputation-based weighting
estimator (when a propensity score model is provided) as detailed in Zhou
and Yamamoto (2020). You may install the \code{paths} package from the
xiangzhou09/paths GitHub repository, using the following code:
\code{devtools::install_github("xiangzhou09/paths")}
}
\details{
\code{pathimp()} estimates path-specific effects using pure regression imputation and (optionally)
an imputation-based weighting estimator, and it computes inferential statistics using the
nonparametric bootstrap.

With K causally ordered mediators, the implementation proceeds as follows:
(i) it fits a model for the mean of the outcome conditional on the exposure and baseline confounders;
(ii) it imputes conventional potential outcomes under using model from (i); (iii) for each mediator
k = 1, 2, ..., K, it then fits (iiia) a model for the mean of the outcome conditional on the exposure,
baseline confounders, and the mediators Mk = {M1, ..., Mk}; (iv) it uses the models from (iii) to
impute cross-world potential outcomes; and (v) and finally, it uses the imputed outcomes from all
the previous steps to calculate estimates for the path-specific effects.

\code{pathimp()} provides estimates for the total effect and K+1 path-specific effects: the direct effect
of the exposure on the outcome that does not operate through any of the mediators, and separate
path-specific effects operating through each of the K mediators, net of the mediators that precede
them in causal order.

If only a single mediator is specified, \code{pathimp()} reverts to estimates of conventional natural
direct and indirect effects through a univariate mediator.
}
\examples{
# Example 1: With one exposure-induced confounder
## Prepare data:
data(nlsy)
df <- 
nlsy[complete.cases(nlsy[,key_vars]),] |>
mutate(
std_cesd_age40 = (cesd_age40 - mean(cesd_age40)) / sd(cesd_age40)
)
## Set up the Y_models:
  glm_m0 <- glm(
    std_cesd_age40 ~ female + black + hispan + paredu + parprof + 
     parinc_prank + famsize + afqt3 + att22,
    data = df
    )
    
  glm_m1 <- glm(
    std_cesd_age40 ~ female + black + hispan + paredu + parprof + 
    parinc_prank + famsize + afqt3 + att22 +  ever_unemp_age3539,
    data = df
    )
    
  glm_m2 <- glm(
    std_cesd_age40 ~ female + black + hispan + paredu + parprof + 
    parinc_prank + famsize + afqt3 + att22 + ever_unemp_age3539 + 
    log_faminc_adj_age3539, 
    data = df
    )
  
glm_ymodels <- list(glm_m0, glm_m1, glm_m2)


## Set up the D_model: 
glm_ps <- glm(
att22 ~ female + black + hispan + paredu + parprof + parinc_prank + 
famsize + afqt3, 
family = binomial("logit"),
data = df
)

# Example 1: Including Imputation-based Weighting Estimator:

## Fit the paths model:
glm_paths <-
pathimp(
D = "att22",
Y = "std_cesd_age40",
M = list("ever_unemp_age3539","log_faminc_adj_age3539"),
Y_models = glm_ymodels,
D_model = glm_ps,
data = df,
boot_reps = 2000,
boot_conf_level = 0.95,
boot_seed = 2138,
boot_parallel = "multicore", # Parallel the bootstrapping
boot_cores = 5,
out_ipw = TRUE
 )

# Example 2: Only Calculate Pure Imputation Estimator:
glm_paths <-
pathimp(
D = "att22",
Y = "std_cesd_age40",
M = list("ever_unemp_age3539","log_faminc_adj_age3539"),
Y_models = glm_ymodels,
data = df,
boot_reps = 2000,
boot_conf_level = 0.95,
boot_seed = 2138,
boot_parallel = "multicore", # Parallel the bootstrapping
boot_cores = 5,
out_ipw = FALSE 
 )
}
