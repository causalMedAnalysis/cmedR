% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pathimp.R
\name{pathimp}
\alias{pathimp}
\title{Regression-Imputation estimator for path-specific effects}
\usage{
pathimp(
  D,
  Y,
  M,
  Y_models,
  D_model = NULL,
  data,
  boot_reps,
  boot_conf_level = 0.95,
  boot_seed = NULL,
  boot_parallel = "no",
  round_decimal = 3,
  boot_cores = max(c(parallel::detectCores() - 2, 1)),
  out_ipw
)
}
\arguments{
\item{D}{A character string indicating the name of the treatment variable in
\code{data}. The treatment should be a binary variable taking either 0 or 1.}

\item{Y}{A character string indicating the name of the outcome variable.}

\item{M}{A list of \eqn{K} character vectors indicating the names of \eqn{K}
causally ordered mediators \eqn{M_1,\ldots, M_K}.}

\item{Y_models}{A list of \eqn{K+1} fitted model objects describing how the
outcome depends on treatment, pretreatment confounders, and varying sets of
mediators, where \eqn{K} is the number of mediators.
\itemize{
\item the first element is a baseline model of the outcome conditional on
treatment and pretreatment confounders.
\item the \eqn{k}th element is an outcome model conditional on treatment,
pretreatment confounders, and mediators \eqn{M_1,\ldots, M_{k-1}}.
\item the last element is an outcome model conditional on treatment,
pretreatment confounders, and all of the mediators, i.e.,
\eqn{M_1,\ldots, M_K}.
}
The fitted model objects can be of type \code{\link{lm}}, \code{\link{glm}},
\code{\link[gbm]{gbm}}, \code{\link[BART]{wbart}}, or \code{\link[BART]{pbart}}.}

\item{D_model}{An optional propensity score model for treatment. It can be
of type \code{\link{glm}},\code{\link[gbm]{gbm}}, \code{\link[twang]{ps}}, or
\code{\link[BART]{pbart}}. When it is provided, the imputation-based weighting
estimator is also used to compute path-specific causal effects. Defaults to
\code{NULL}. Must be explicitly specified when \code{out_ipw = TRUE} to compute the
imputation-based weighting estimator.}

\item{data}{A data frame.}

\item{boot_reps}{An integer scalar for the number of bootstrap replications to perform.}

\item{boot_conf_level}{A numeric scalar for the confidence level of the
bootstrap interval.}

\item{boot_seed}{An integer scalar specifying the random-number seed used in
bootstrap resampling. Defaults to \code{NULL}, indicating that no seed is set.}

\item{boot_parallel}{Type of parallel operation to be used. Follows the same
specification as the \code{\link[boot]{boot}} package. Defaults to \code{"no"}.}

\item{round_decimal}{The number of decimal digits to which results are
rounded and displayed.}

\item{boot_cores}{An integer scalar specifying the number of CPU cores on
which the parallelized bootstrap will run. This argument only has an effect
if you requested a parallelized bootstrap (i.e., only if \code{boot_parallel} is
not \code{no}). By default, \code{boot_cores} is equal to the greater of two values:
(a) one and (b) the number of available CPU cores minus two. If \code{boot_cores}
equals one, then the bootstrap loop will not be parallelized (regardless of
the setting of \code{boot_parallel}).}

\item{out_ipw}{A logical value indicating whether to report the
imputation-based weighting estimator. If set to \code{TRUE}, the user must
specify the propensity score model to calculate the Imputation-based Weighting
Estimator . If \code{FALSE}, only the Pure Imputation Estimator will be
returned.}
}
\value{
When \code{out_ipw = TRUE}, \code{pathimp()} returns a data frame with the
following information: \describe{
\item{Pure Imputation Estimator}{Estimates the direct (ATE) and path-specific
effects (PSE)  through mediators \eqn{M_1, \ldots, M_K} using the pure
imputation estimator, along with corresponding bootstrap confidence intervals.}
\item{Imputation-based Weighting Estimator}{Estimates of direct and
path-specific effects via \eqn{M_1, \ldots, M_K} based on the imputation-based
weighting estimator,along with corresponding bootstrap confidence intervals.}
} When \code{out_ipw = FALSE}, only the pure imputation estimator will be
returned.
}
\description{
\code{pathimp()} is a wrapper for two functions from the \code{paths} package. It
implements the pure imputation estimator and the imputation-based weighting
estimator (when a propensity score model is provided) as detailed in Zhou
and Yamamoto (2020). You may install the \code{paths} package from CRAN or GitHub:
\code{devtools::install_github("xiangzhou09/paths")}
}
\details{
\code{pathimp()} estimates path-specific effects using pure regression imputation and (optionally)
an imputation-based weighting estimator, and it computes inferential statistics using the
nonparametric bootstrap.

With K causally ordered mediators, the implementation proceeds as follows:
(i) it fits a model for the mean of the outcome conditional on the exposure and baseline confounders;
(ii) it imputes conventional potential outcomes under using model from (i); (iii) for each mediator
k = 1, 2, ..., K, it then fits (iiia) a model for the mean of the outcome conditional on the exposure,
baseline confounders, and the mediators Mk = \{M1, ..., Mk\}; (iv) it uses the models from (iii) to
impute cross-world potential outcomes; and (v) and finally, it uses the imputed outcomes from all
the previous steps to calculate estimates for the path-specific effects.

\code{pathimp()} provides estimates for the total effect and K+1 path-specific effects: the direct effect
of the exposure on the outcome that does not operate through any of the mediators, and separate
path-specific effects operating through each of the K mediators, net of the mediators that precede
them in causal order.

If only a single mediator is specified, \code{pathimp()} reverts to estimates of conventional natural
direct and indirect effects through a univariate mediator.
}
\examples{
# Example 1: Pure imputation with two mediators
## Prepare data:
data(nlsy)
covariates <- c(
"female",
"black",
"hispan",
"paredu",
"parprof",
"parinc_prank",
"famsize",
"afqt3"
)

key_variables <- c(
"cesd_age40",
"ever_unemp_age3539",
"log_faminc_adj_age3539",
"att22",
covariates
)

df <-
nlsy[complete.cases(nlsy[,key_variables]),] |>
dplyr::mutate(
std_cesd_age40 = (cesd_age40 - mean(cesd_age40)) / sd(cesd_age40)
)

glm_m0 <- glm(
  std_cesd_age40 ~ female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3 + att22,
  data = df
)
glm_m1 <- glm(
  std_cesd_age40 ~ female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3 + att22 + ever_unemp_age3539,
  data = df
)
glm_m2 <- glm(
  std_cesd_age40 ~ female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3 + att22 + ever_unemp_age3539 +
    log_faminc_adj_age3539,
  data = df
)
glm_ymodels <- list(glm_m0, glm_m1, glm_m2)

# Fit the paths model:
fit_ex1 <- pathimp(
  D = "att22",
  Y = "std_cesd_age40",
  M = list("ever_unemp_age3539","log_faminc_adj_age3539"),
  Y_models = glm_ymodels,
  data = df,
  boot_reps = 250,
  boot_conf_level = 0.95,
  boot_seed = 2138,
  boot_parallel = "multicore", # Parallel the bootstrapping
  out_ipw = FALSE
)
print(fit_ex1)

# Example 2: Adding imputation-based weighting
glm_ps <- glm(
  att22 ~ female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3,
  family = binomial("logit"),
  data = df
)
# Fit the paths model:
fit_ex2 <- pathimp(
  D = "att22",
  Y = "std_cesd_age40",
  M = list("ever_unemp_age3539","log_faminc_adj_age3539"),
  Y_models = glm_ymodels,
  D_model = glm_ps,
  data = df,
  boot_reps = 250,
  boot_conf_level = 0.95,
  boot_seed = 2138,
  boot_parallel = "multicore", # Parallel the bootstrapping
  out_ipw = TRUE
)
print(fit_ex2)

# Example 3: Pure imputation with three mediators

# Prepare data
key_variables3 <- c(
  "cesd_age40","cesd_1992","ever_unemp_age3539","log_faminc_adj_age3539",
  "att22", covariates
)
df3 <- nlsy[complete.cases(nlsy[,key_variables3]),] |>
  dplyr::mutate(
    std_cesd_age40 = (cesd_age40 - mean(cesd_age40)) / sd(cesd_age40)
  )

glm_m0 <- glm(
  std_cesd_age40 ~ female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3 + att22,
  data = df3
)
glm_m1 <- glm(
  std_cesd_age40 ~ female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3 + att22 + cesd_1992,
  data = df3
)
glm_m2 <- glm(
  std_cesd_age40 ~ female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3 + att22 + cesd_1992 +
    ever_unemp_age3539,
  data = df3
)
glm_m3 <- glm(
  std_cesd_age40 ~ female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3 + att22 + cesd_1992 +
    ever_unemp_age3539 + log_faminc_adj_age3539,
  data = df3
)
glm_ymodels3 <- list(glm_m0, glm_m1, glm_m2, glm_m3)

# Fit the paths model:
\dontrun{
fit_ex3 <- pathimp(
  D = "att22",
  Y = "std_cesd_age40",
  M = list("cesd_1992","ever_unemp_age3539","log_faminc_adj_age3539"),
  Y_models = glm_ymodels3,
  data = df3,
  boot_reps = 250,
  boot_conf_level = 0.95,
  boot_seed = 2138,
  boot_parallel = "multicore", # Parallel the bootstrapping
  out_ipw = FALSE
)
print(fit_ex3)
}

# Example 4: Pure imputation with two mediators including treatmentâ€“mediator
#            interactions

glm_m0 <- glm(
  std_cesd_age40 ~ female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3 + att22,
  data = df
)

# Outcome models including treatment-mediator interactions
glm_m1 <- glm(
  std_cesd_age40 ~ female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3 + att22 * ever_unemp_age3539,
  data = df
)
glm_m2 <- glm(
  std_cesd_age40 ~ female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3 + att22 *
    (ever_unemp_age3539 + log_faminc_adj_age3539) ,
  data = df
)
glm_ymodels_intM <- list(glm_m0, glm_m1, glm_m2)

# Fit the paths model:
fit_ex4 <- pathimp(
  D = "att22",
  Y = "std_cesd_age40",
  M = list("ever_unemp_age3539","log_faminc_adj_age3539"),
  Y_models = glm_ymodels_intM,
  data = df,
  boot_reps = 250,
  boot_conf_level = 0.95,
  boot_seed = 2138,
  boot_parallel = "multicore", # Parallel the bootstrapping
  out_ipw = FALSE
)
print(fit_ex4)


# Example 5: Pure imputation with two mediators including treatmentâ€“mediator
#            and treatmentâ€“confounder interactions

glm_m0 <- glm(
  std_cesd_age40 ~ (female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3) * att22,
  data = df
)

# Outcome models including treatment-mediator and treatment-confounder
# interactions
glm_m1 <- glm(
  std_cesd_age40 ~ (female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3 + ever_unemp_age3539) * att22,
  data = df
)
glm_m2 <- glm(
  std_cesd_age40 ~ (female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3 + ever_unemp_age3539 +
    log_faminc_adj_age3539) * att22,
  data = df
)
glm_ymodels_intMC <- list(glm_m0, glm_m1, glm_m2)

# Fit the paths model:
fit_ex5 <- pathimp(
  D = "att22",
  Y = "std_cesd_age40",
  M = list("ever_unemp_age3539","log_faminc_adj_age3539"),
  Y_models = glm_ymodels_intMC,
  data = df,
  boot_reps = 250,
  boot_conf_level = 0.95,
  boot_seed = 2138,
  boot_parallel = "multicore", # Parallel the bootstrapping
  out_ipw = FALSE
)
print(fit_ex5)

# Example 6: Pure imputation with 1 mediator

# Prepare data
key_variables1 <- c("cesd_age40","ever_unemp_age3539","att22", covariates)

df1 <- nlsy[complete.cases(nlsy[,key_variables1]),] |>
  dplyr::mutate(
    std_cesd_age40 = (cesd_age40 - mean(cesd_age40)) / sd(cesd_age40)
  )

glm_m0 <- glm(
  std_cesd_age40 ~ female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3 + att22,
  data = df1
)
glm_m1 <- glm(
  std_cesd_age40 ~ female + black + hispan + paredu + parprof +
    parinc_prank + famsize + afqt3 + att22 + ever_unemp_age3539,
  data = df1
)
glm_ymodels1 <- list(glm_m0, glm_m1)

# Fit the paths model:
fit_ex6 <- pathimp(
  D = "att22",
  Y = "std_cesd_age40",
  M = list("ever_unemp_age3539"),
  Y_models = glm_ymodels1,
  data = df1,
  boot_reps = 250,
  boot_conf_level = 0.95,
  boot_seed = 2138,
  boot_parallel = "multicore", # Parallel the bootstrapping
  out_ipw = FALSE
)
print(fit_ex6)

# Note: With a single mediator, the effect labeled as the path-specific
# effect (D -> M -> Y) is the natural indirect effect (NIE), and the
# effect of the direct path (D -> Y) is the natural direct effect (NDE).

}
