% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dmlpath.R
\name{dmlpath}
\alias{dmlpath}
\title{Debiased Machine Learning (DML) Estimation for Path-specific Effects}
\usage{
dmlpath(
  D,
  Y,
  M,
  C,
  data,
  d,
  dstar,
  censor = TRUE,
  censor_low = 0.01,
  censor_high = 0.99,
  interaction_DM = FALSE,
  interaction_DC = FALSE,
  interaction_MC = FALSE,
  num_folds = 5,
  V = 5L,
  seed,
  SL.library = c("SL.mean", "SL.glmnet"),
  stratifyCV = TRUE
)
}
\arguments{
\item{D}{A character scalar identifying the name of the exposure variable in
\code{data}. \code{D} is a character string, but the exposure variable it identifies
must be numeric and binary, with two distinct values.}

\item{Y}{A character scalar identifying the name of the outcome variable in
\code{data}. \code{Y} is a character string, but the outcome variable it identifies
must be numeric.}

\item{M}{A character list (of one or more elements) identifying the names
of the mediator variables in \code{data}. If you are estimating univariate
natural effects (with a single mediator), \code{M} should be a character scalar
(i.e., a vector with only one element)—e.g., \code{M = "ever_unemp_age3539"}. If you
are estimating multivariate natural effects (with multiple mediators), \code{M}
should be a list identifying all mediators—e.g.,
\code{M = list("ever_unemp_age3539", "log_faminc_adj_age3539")}.}

\item{C}{A character vector (of one or more elements) identifying the names
of the covariate variables in \code{data} that you wish to include in both the
mediator and outcome models. If there are no such covariates you wish to
include, leave \code{C} as its default null argument.}

\item{data}{A data frame.}

\item{d}{The numeric value of the treatment variable that the user defines as
the treatment status. If not equal to 1, the function will recode it as 1.}

\item{dstar}{The numeric value of the treatment variable that the user defines
as the control status. If not equal to 0, the function will recode it as 0.}

\item{censor}{A logical scalar indicating whether the IPW weights that enter
the estimating equations should be censored. By default, this value is \code{TRUE}.}

\item{censor_low, censor_high}{A pair of arguments, each a numeric scalar
denoting a probability in [0,1]. If \code{censor} is TRUE, then IPW weights below
the \code{censor_low} quantile will be bottom-coded, and weights above the
\code{censor_high} quantile will be top-coded. E.g., if the default values
\code{censor_low = 0.01} and \code{censor_high = 0.99} are used, then IPW weights will
be censored at their 1st and 99th percentiles. By default, weights are censored
to the [1st, 99th] percentile range.}

\item{interaction_DM}{A logical scalar indicating whether the outcome model
should include exposure-mediator interactions (interactions of the exposure
with each mediator if there is more than one mediator in \code{M}).}

\item{interaction_DC}{A logical scalar indicating whether both the outcome
model and each of the mediator models should include interactions of the
exposure with each covariate in \code{C}.}

\item{interaction_MC}{A logical scalar indicating whether the outcome model
should include interactions of each mediator in \code{M} with each covariate in
\code{C}.}

\item{num_folds}{Integer. The number of folds (partitions) used for repeated cross-fitting.
The data is randomly divided into \code{K} approximately equal-sized subsets.
Models are trained on \code{K - 1} folds and evaluated on the held-out fold.
The procedure is repeated across all partitions. Typical values range from 4 to 10.
The default number is \code{5}.}

\item{V}{Integer. The number of folds used in the Super Learner's internal cross-validation.
procedure for training and evaluating candidate algorithms. Must be an explicit
integer (e.g., \code{5L}) to ensure proper handling by certain functions.
The default number is \code{5L}.}

\item{seed}{Seed value for reproducibility. Controls the randomization in cross-validation
and other stochastic components of the estimation procedure.}

\item{SL.library}{Character vector. Specifies the set of candidate algorithms to be
used in the Super Learner ensemble. Each element should be the name of a valid learner
(e.g., \code{"SL.mean"}, \code{"SL.glmnet"}, \code{"SL.ranger"}). Learners can
be chosen from the base learners available in the \pkg{SuperLearner} package or user-defined wrappers.
The default learners are \code{c("SL.mean", "SL.glmnet")}.}

\item{stratifyCV}{Logical. If \code{TRUE}, stratified sampling is used when creating cross-validation
folds within each SuperLearner for the treatment, preserving the distribution of the treatment variable
across folds. The default setting is \code{TRUE}.}
}
\value{
By default, \code{dmlpath()} returns a tibble with the following columns:

\item{Estimand}{A character vector describing each estimand, including the total effect (ATE)
and the path-specific effects (PSEs) for each mediator path. Notation follows the format used
in Wodtke and Zhou, e.g., \eqn{ATE(1,0)} or \eqn{PSE: D → M1 → Y(1,0)}.}

\item{Mean}{A numeric vector of point estimates for each estimand.}

\item{SE}{A numeric vector of standard errors corresponding to each point estimate.}

\item{out}{A character vector combining the rounded point estimate and its 95\% confidence
interval in the format: \code{"estimate [lower, upper]"}, where the interval is constructed
as \verb{Mean ± 1.96 × SE}.}
}
\description{
\code{dmlpath()} uses a debiased machine learning approach to estimate path-specific
effects.If there are K causally ordered mediators, dmlpath provides estimates
for: a direct effect of the exposure on the outcome that does not operate through
any of the mediators, and then K path-specific effects, with each of these
effects operating through one mediator, net of the mediators preceding it in
causal order. If only one mediator is specified, \code{dmlpath()} computes
conventional natural direct and indirect effects.
}
\details{
\code{dmlpath()} estimates path specific effects using debiased machine learning. It will
repeatedly implement the type 2 multiply robust estimator in the \code{dmlmed()} function
to compute natural effects, and then take differences between these effects
to generate the PSEs of interest.

The Type 2 estimator (Equation 6.20 in Wodtke and Zhou) requires modeling
P(D|C), P(D|C,M), E(Y|C,M,D), and E(E(Y|C,M,D=d)|C,D). The \code{dmlpath()} function uses
the SuperLearner algorithm, allowing users to specify multiple machine learning algorithms
and to estimate the above models non-parametrically.
#' To compute path-specific effects with K causally ordered mediators, \code{dmlpath()}
recursively estimates a series of natural direct effects (NDEs).
Specifically:
\itemize{
\item The path-specific direct effect from treatment to outcome, bypassing all mediators,
is given by \eqn{\text{PSE}_{D \to Y}(d, d^*) = \text{NDE}_{M}(d, d^*)}.
\item For each intermediate mediator \eqn{M_k}, the path-specific effect is computed
as the difference between successive NDEs:
\eqn{
  \text{PSE}_{D \to M_k \rightsquigarrow Y}(d, d^*) = \text{NDE}_{M_{k-1}}(d, d^*) - \text{NDE}_{M_k}(d, d^*).
  }
\item The first path-specific effect (from \eqn{ D \to M_1 \rightsquigarrow Y }) is equal
to the natural indirect effect for \eqn{ M_1 }, i.e.:
\eqn{
  \text{PSE}_{D \to M_1 \rightsquigarrow Y}(d, d^*) = \text{NIE}_{M_1}(d, d^*).
  }
}

Specifying the \code{M} Argument:

The \code{M} argument is a list of character vectors identifying the names of the
mediator variables. This argument is purposely a list of vectors rather than
simply a vector because it accommodates both univariate and multivariate
mediators. To explain, let's start with a simple example.

Suppose you have two single mediators, named \code{ever_unemp_age3539} and
\code{log_faminc_adj_age3539}, where \code{ever_unemp_age3539} causally precedes
\code{log_faminc_adj_age3539}. In this case, you would use the following syntax:
\code{M = list("ever_unemp_age3539", "log_faminc_adj_age3539")}.

Now, let's say you have a third mediator, named \code{m3}. You believe that
\code{ever_unemp_age3539} causally precedes both \code{log_faminc_adj_age3539} and
\code{m3}. But you are unwilling to make an assumption about the relative causal
order of \code{log_faminc_adj_age3539} and \code{m3} (whether \code{log_faminc_adj_age3539}
causally precedes \code{m3} or vice versa). In that case, you could treat
\code{log_faminc_adj_age3539} and \code{m3} as a whole, using the following syntax:
\code{M = list("ever_unemp_age3539", c("log_faminc_adj_age3539", "m3"))}.

Note that the order of the elements in the \code{c("log_faminc_adj_age3539", "m3")}
vector does not matter (it could alternatively be written as
\code{c("m3", "log_faminc_adj_age3539")}). But the order of the vectors in the
list does matter. And in this example, the mediator identified by the first
element in the list, the \code{"ever_unemp_age3539"} scalar, is assumed to
causally precede the two mediators collectively identified by the second
element in the list, the \code{c("log_faminc_adj_age3539", "m3")} vector.

Finally, note that if one of your mediators is a nominal factor variable, we
recommend that you dummy code the levels of the factor and treat the dummy
variables as a multivariate whole. For instance, let's say that you have a
fourth mediator, which causally follows \code{ever_unemp_age3539},
\code{log_faminc_adj_age3539}, and \code{m3}. This fourth mediator is a nominal
variable with four levels. If you create numeric dummy variables for three
levels (omitting a reference level), named \code{level2}, \code{level3}, \code{level4},
then you can use the following syntax for the \code{M} argument:
\code{M = list("ever_unemp_age3539", c("log_faminc_adj_age3539", "m3"), c("level2","level3","level4"))}.
}
\examples{

# ----------------------------- #
#     Data and shared setup     #
# ----------------------------- #
data(nlsy)

# outcome
Y <- "std_cesd_age40"

# exposure
D <- "att22"

# mediators
M <- list(
  "ever_unemp_age3539",
  "log_faminc_adj_age3539"
)

covariates <- c(
  "female","black","hispan","paredu","parprof",
  "parinc_prank","famsize","afqt3"
)

key_variables <- c("cesd_age40", unlist(M), D, covariates)
nlsy_ex <- nlsy[complete.cases(nlsy[, key_variables]), ]
nlsy_ex$std_cesd_age40 <-
  (nlsy_ex$cesd_age40 - mean(nlsy_ex$cesd_age40)) / sd(nlsy_ex$cesd_age40)

# ------------------------------------------ #
# Example 1: Two mediators                   #
# Super Learner: Marginal mean and Lasso     #
# -------------------------------------------#
dmlpath(
  data = nlsy_ex,
  D = D,
  M = M,
  Y = Y,
  C = covariates,
  d = 1, dstar = 0,
  num_folds = 5, V = 5L, seed = 1234,
  SL.library = c("SL.mean","SL.glmnet"),
  stratifyCV = TRUE
)

# ------------------------------------------------------ #
# Example 2: Two mediators                               #
# Super Learner: Marginal mean, Lasso and Random forest  #
# ------------------------------------------------------ #
\dontrun{
dmlpath(
  data = nlsy_ex,
  D = D,
  M = M,
  Y = Y,
  C = covariates,
  d = 1, dstar = 0,
  num_folds = 5, V = 5L, seed = 1234,
  SL.library = c("SL.mean","SL.glmnet","SL.ranger"),
  stratifyCV = TRUE
)
}

# ------------------------------------------------------ #
# Example 3: Single mediator                             #
# Super Learner: Marginal mean, Lasso and Random forest  #
# ------------------------------------------------------ #
# With a single mediator, the function returns ATE, NDE, and NIE.
\dontrun{
dmlpath(
  data = nlsy_ex,
  D = D,
  M = "ever_unemp_age3539",
  Y = Y,
  C = covariates,
  d = 1, dstar = 0,
  num_folds = 5, V = 5L, seed = 1234,
  SL.library = c("SL.mean","SL.glmnet","SL.ranger"),
  stratifyCV = TRUE
)
}

# --------------------------------------------------------#
# Example 4: Three mediators                              #
# Super Learner: Marginal mean, Lasso and Random forest   #
# ------------------------------------------------------- #
key_variables4 <- c("cesd_age40","cesd_1992","ever_unemp_age3539",
                    "log_faminc_adj_age3539", D, covariates)
nlsy_ex4 <- nlsy[complete.cases(nlsy[, key_variables4]), ]
nlsy_ex4$std_cesd_age40 <-
  (nlsy_ex4$cesd_age40 - mean(nlsy_ex4$cesd_age40)) / sd(nlsy_ex4$cesd_age40)

\dontrun{
dmlpath(
  data = nlsy_ex4,
  D = D,
  M = list("cesd_1992","ever_unemp_age3539","log_faminc_adj_age3539"),
  Y = Y,
  C = covariates,
  d = 1, dstar = 0,
  num_folds = 5, V = 5L, seed = 1234,
  SL.library = c("SL.mean","SL.glmnet","SL.ranger"),
  stratifyCV = TRUE
)
}
}
