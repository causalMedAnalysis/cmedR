% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ipwpath.R
\name{ipwpath}
\alias{ipwpath}
\title{Inverse probability weighting (IPW) estimator for path-specific effects}
\usage{
ipwpath(
  data,
  D,
  M,
  Y,
  C = NULL,
  base_weights_name = NULL,
  stabilize = TRUE,
  censor = TRUE,
  censor_low = 0.01,
  censor_high = 0.99,
  boot = FALSE,
  boot_reps = 1000,
  boot_conf_level = 0.95,
  boot_seed = NULL,
  boot_parallel = FALSE,
  boot_cores = max(c(parallel::detectCores() - 2, 1))
)
}
\arguments{
\item{data}{A data frame.}

\item{D}{A character scalar identifying the name of the exposure variable in
\code{data}. \code{D} is a character string, but the exposure variable it identifies
must be numeric.}

\item{M}{A character vector (of one or more elements) identifying the names
of the mediator variables in \code{data}. The character vector MUST specify the
mediators in causal order, starting from the first in the hypothesized
causal sequence to the last. If you only specify a single mediator
variable, then the function will simply return the natural effects. Also
note that \code{M} is a character vector, but the mediator variable(s) it
identifies must each be numeric.}

\item{Y}{A character scalar identifying the name of the outcome variable in
\code{data}. \code{Y} is a character string, but the outcome variable it identifies
must be numeric.}

\item{C}{A character vector (of one or more elements) identifying the names
of the covariate variables in \code{data} that you wish to include in the
exposure models. If there are no such covariates you wish to include, leave
\code{C} as its default null argument.}

\item{base_weights_name}{A character scalar identifying the name of the base
weights variable in \code{data}, if applicable (e.g., if you have---and want to
use---sampling weights).}

\item{stabilize}{A logical scalar indicating whether the IPW weights should
be stabilized (multiplied by the marginal probabilities of the exposure).}

\item{censor}{A logical scalar indicating whether the IPW weights should
be censored.}

\item{censor_low, censor_high}{A pair of arguments, each a numeric scalar
denoting a probability with values in \link{0,1}. If the \code{censor} argument is
TRUE, then IPW weights below the \code{censor_low} quantile will be
bottom-coded, and IPW weights above the \code{censor_high} quantile will be
top-coded (before multiplying by a rescaled version of the base weights, if
applicable). E.g., if the default options of \code{censor_low = 0.01} and
\code{censor_high = 0.99} are used, then the IPW weights will be censored at
their 1st and 99th percentiles in the data.}

\item{boot}{A logical scalar indicating whether the function will perform the
nonparametric bootstrap and return two-sided confidence intervals and
p-values.}

\item{boot_reps}{An integer scalar for the number of bootstrap replications
to perform.}

\item{boot_conf_level}{A numeric scalar for the confidence level of the
bootstrap interval.}

\item{boot_seed}{An integer scalar specifying the random-number seed used in
bootstrap resampling.}

\item{boot_parallel}{A logical scalar indicating whether the bootstrap will
be performed with a parallelized loop, with the goal of reducing runtime.
Parallelized computing, as implemented in this function, requires that you
have each of the following R packages installed: \code{doParallel}, \code{doRNG}, and
\code{foreach}. (However, you do not need to load/attach these three packages
with the \code{library} function prior to running this function.) Note that the
results of the parallelized bootstrap may differ slightly from the
non-parallelized bootstrap, even if you specify the same seed, due to
differences in how the seed is processed by the two methods.}

\item{boot_cores}{An integer scalar specifying the number of CPU cores on
which the parallelized bootstrap will run. This argument only has an effect
if you requested a parallelized bootstrap (i.e., only if \code{boot} is TRUE and
\code{boot_parallel} is TRUE). By default, \code{boot_cores} is equal to the greater
of two values: (a) one and (b) the number of available CPU cores minus two.
If \code{boot_cores} equals one, then the bootstrap loop will not be
parallelized (regardless of whether \code{boot_parallel} is TRUE).}
}
\value{
By default, \code{ipwpath()} returns a list with the following elements:
\item{ATE}{A numeric scalar with the estimated total average treatment effect
for the exposure contrast \code{d - dstar}: ATE(\code{d},\code{dstar}).}
\item{PSE}{A numeric vector, of length \code{length(M)+1}, with the estimated
path-specific effects for the exposure contrast \code{d - dstar}. The vector is
named with the path each effect describes.}
\item{weights1}{A numeric vector with the final inverse probability weights
for w_1 (as defined in the book), used to estimate the multivariate natural
effects for each set of mediators, M_1 to M_k.}
\item{weights2}{A numeric vector with the final inverse probability weights
for w_2 (as defined in the book), used to estimate the multivariate natural
effects for each set of mediators, M_1 to M_k.}
\item{weights3}{A numeric matrix with the final inverse probability weights
for w_3 (as defined in the book), used to estimate the multivariate natural
effects for each set of mediators, M_1 to M_k. Unlike w_1 and w_2, the w_3
weights are unique for each set of mediators. Therefore, the matrix
consists of \code{length(M)} columns, with each column containing the w_3
weights for mediators M_1 to M_k.}
\item{model_d1}{The model object from the first fitted exposure model
(of the exposure given baseline covariates, denoted in the book as f(D|C)),
used in the estimation of the multivariate natural effects for each set of
mediators, M_1 to M_k. Since the predictors in the model do not include the
mediators, the same model is used for each set of mediators, and there is
only one model object returned.}
\item{models_d2}{A list of the model objects from the second fitted exposure
model (of the exposure given baseline covariates and the mediator(s),
denoted in the book as s(D|C,M)), used in the estimation of the
multivariate natural effects for each set of mediators, M_1 to M_k. Since
the predictors in the model do include the mediators, a different model is
fitted for each set of mediators, and the returned object is a list of
model objects.}

If you request the bootstrap (by setting the \code{boot} argument to TRUE), then
the function returns all of the elements listed above, as well as the
following additional elements:
\item{ci_ATE}{A numeric vector with the bootstrap confidence interval for the
total average treatment effect (ATE).}
\item{ci_PSE}{A numeric matrix with the bootstrap confidence interval for
each path-specific effect (PSE).}
\item{pvalue_ATE}{A numeric scalar with the p-value from a two-sided test of
whether the ATE is different from zero, as computed from the bootstrap.}
\item{pvalue_PSE}{A numeric matrix with each p-value from a two-sided test of
whether the PSE is different from zero, as computed from the bootstrap.}
\item{boot_ATE}{A numeric vector of length \code{boot_reps} comprising the ATE
estimates from all replicate samples created in the bootstrap.}
\item{boot_PSE}{A numeric matrix, of \code{length(M)+1} columns and \code{boot_reps}
rows, comprising all PSE estimates from all replicate samples created in
the bootstrap.}
}
\description{
\code{ipwpath()} uses the inverse probability weighting estimator to estimate the
total effect (ATE) and path-specific effects (PSEs).
}
\details{
\code{ipwpath()} uses inverse probability weighting to estimate path-specific effects through
multiple mediators, and it computes inferential statistics using the nonparametric bootstrap.
It constructs weights using logit models for the exposure, each conditioned on different combinations
of mediators and the baseline confounders. This approach allows the isolation of effects
that pass through specific causal pathways defined by the ordered mediators. For example,
with two causally ordered mediators (M1, M2), it estimates: a model for the exposure with
no mediators, just the baseline confounders as predictors; a model for the exposure with M1
and the baseline confounders as predictors; and a model for the exposure with M1, M2, and the
baseline confounders as predictors. These models are used to construct a set of inverse probability
weights, which then enable the calculation of direct and path-specific effects that operate through
each mediator, net of the mediators that precede it causal order.

Specifying the \code{M} Argument:

The \code{M} argument is a list of character vectors identifying the names of the
mediator variables. This argument is purposely a list of vectors rather than
simply a vector because it accommodates both univariate and multivariate
mediators. To explain, let's start with a simple example.

Suppose you have two single mediators, named \code{ever_unemp_age3539} and
\code{log_faminc_adj_age3539}, where \code{ever_unemp_age3539} causally precedes
\code{log_faminc_adj_age3539}. In this case, you would use the following syntax:
\code{M = list("ever_unemp_age3539", "log_faminc_adj_age3539")}.

Now, let's say you have a third mediator, named \code{m3}. You believe that
\code{ever_unemp_age3539} causally precedes both \code{log_faminc_adj_age3539} and
\code{m3}. But you are unwilling to make an assumption about the relative causal
order of \code{log_faminc_adj_age3539} and \code{m3} (whether \code{log_faminc_adj_age3539}
causally precedes \code{m3} or vice versa). In that case, you could treat
\code{log_faminc_adj_age3539} and \code{m3} as a whole, using the following syntax:
\code{M = list("ever_unemp_age3539", c("log_faminc_adj_age3539", "m3"))}.

Note that the order of the elements in the \code{c("log_faminc_adj_age3539", "m3")}
vector does not matter (it could alternatively be written as
\code{c("m3", "log_faminc_adj_age3539")}). But the order of the vectors in the
list does matter. And in this example, the mediator identified by the first
element in the list, the \code{"ever_unemp_age3539"} scalar, is assumed to
causally precede the two mediators collectively identified by the second
element in the list, the \code{c("log_faminc_adj_age3539", "m3")} vector.

Finally, note that if one of your mediators is a nominal factor variable, we
recommend that you dummy-encode the levels of the factor and treat the dummy
variables as a multivariate whole. For instance, let's say that you have a
fourth mediator, which causally follows \code{ever_unemp_age3539},
\code{log_faminc_adj_age3539}, and \code{m3}. This fourth mediator is a nominal
variable with four levels. If you create numeric dummy variables for three
levels (omitting a reference level), named \code{level2}, \code{level3}, \code{level4},
then you can use the following syntax for the \code{M} argument:
\code{M = list("ever_unemp_age3539", c("log_faminc_adj_age3539", "m3"),  c("level2","level3","level4"))}.
}
\examples{
# Example 1: Two mediators
## Prepare data
## For convenience with this example, we will use complete cases
data(nlsy)
covariates <- c(
  "female",
  "black",
  "hispan",
  "paredu",
  "parprof",
  "parinc_prank",
  "famsize",
  "afqt3"
)
key_variables <- c(
  "cesd_age40",
  "ever_unemp_age3539",
  "log_faminc_adj_age3539",
  "att22",
  covariates
)
nlsy <- nlsy[complete.cases(nlsy[,key_variables]),]
nlsy$std_cesd_age40 <- 
  (nlsy$cesd_age40 - mean(nlsy$cesd_age40)) / 
  sd(nlsy$cesd_age40)
## Estimate path-specific effects
ipwpath(
  data = nlsy,
  D = "att22",
  M = c("ever_unemp_age3539", "log_faminc_adj_age3539"),
  # ^ note that this order encodes our assumption that ever_unemp_age3539 
  # causally precedes log_faminc_adj_age3539
  Y = "std_cesd_age40",
  C = c(
    "female",
    "black",
    "hispan",
    "paredu",
    "parprof",
    "parinc_prank",
    "famsize",
    "afqt3"
  )
)

# Example 2: If you specify only a single mediator, the function will return 
# the natural effects (NDE and NIE), in addition to the ATE
ipwpath(
  data = nlsy,
  D = "att22",
  M = "ever_unemp_age3539",
  Y = "std_cesd_age40",
  C = c(
    "female",
    "black",
    "hispan",
    "paredu",
    "parprof",
    "parinc_prank",
    "famsize",
    "afqt3"
  )
)

# Example 3: Incorporating sampling weights
ipwpath(
  data = nlsy,
  D = "att22",
  M = c("ever_unemp_age3539", "log_faminc_adj_age3539"),
  Y = "std_cesd_age40",
  C = c(
    "female",
    "black",
    "hispan",
    "paredu",
    "parprof",
    "parinc_prank",
    "famsize",
    "afqt3"
  ),
  base_weights_name = "weight"
)

# Example 4: Perform a nonparametric bootstrap, with 2,000 replications
\dontrun{
  ipwpath(
    data = nlsy,
    D = "att22",
    M = c("ever_unemp_age3539", "log_faminc_adj_age3539"),
    Y = "std_cesd_age40",
    C = c(
      "female",
      "black",
      "hispan",
      "paredu",
      "parprof",
      "parinc_prank",
      "famsize",
      "afqt3"
    ),
    boot = TRUE,
    boot_reps = 2000,
    boot_seed = 1234
  )
}

# Example 5: Parallelize the bootstrap, to attempt to reduce runtime
# Note that this requires you to have installed the `doParallel`, `doRNG`, 
# and `foreach` packages.
\dontrun{
  ipwpath(
    data = nlsy,
    D = "att22",
    M = c("ever_unemp_age3539", "log_faminc_adj_age3539"),
    Y = "std_cesd_age40",
    C = c(
      "female",
      "black",
      "hispan",
      "paredu",
      "parprof",
      "parinc_prank",
      "famsize",
      "afqt3"
    ),
    boot = TRUE,
    boot_reps = 2000,
    boot_seed = 1234,
    boot_parallel = TRUE
  )
}
}
